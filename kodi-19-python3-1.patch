From ba92831983d2c52ba3f5ffc51f18286d52b5c964 Mon Sep 17 00:00:00 2001
From: fuzzard <fuzzard@kodi.tv>
Date: Mon, 31 Aug 2020 20:35:46 +1000
Subject: [PATCH] [clang-format] interface/python/PythonInvoker.*

---
 xbmc/interfaces/python/PythonInvoker.cpp | 101 +++++++++++++++--------
 xbmc/interfaces/python/PythonInvoker.h   |  17 ++--
 2 files changed, 75 insertions(+), 43 deletions(-)

diff --git a/xbmc/interfaces/python/PythonInvoker.cpp b/xbmc/interfaces/python/PythonInvoker.cpp
index e00cc1ff8632..6254e892a4dd 100644
--- a/xbmc/interfaces/python/PythonInvoker.cpp
+++ b/xbmc/interfaces/python/PythonInvoker.cpp
@@ -6,9 +6,10 @@
  *  See LICENSES/README.md for more information.
  */
 
+// clang-format off
 // python.h should always be included first before any other includes
 #include <Python.h>
-#include <iterator>
+// clang-format on
 
 #include "Application.h"
 #include "PythonInvoker.h"
@@ -40,9 +41,10 @@
 // clang-format on
 
 #include <cassert>
+#include <iterator>
 
 #ifdef TARGET_WINDOWS
-extern "C" FILE *fopen_utf8(const char *_Filename, const char *_Mode);
+extern "C" FILE* fopen_utf8(const char* _Filename, const char* _Mode);
 #else
 #define fopen_utf8 fopen
 #endif
@@ -63,7 +65,8 @@ using namespace KODI::MESSAGING;
 
 CCriticalSection CPythonInvoker::s_critical;
 
-static const std::string getListOfAddonClassesAsString(XBMCAddon::AddonClass::Ref<XBMCAddon::Python::PythonLanguageHook>& languageHook)
+static const std::string getListOfAddonClassesAsString(
+    XBMCAddon::AddonClass::Ref<XBMCAddon::Python::PythonLanguageHook>& languageHook)
 {
   std::string message;
   CSingleLock l(*(languageHook.get()));
@@ -81,11 +84,13 @@ static const std::string getListOfAddonClassesAsString(XBMCAddon::AddonClass::Re
   return message;
 }
 
-static std::vector<std::vector<wchar_t>> storeArgumentsCCompatible(std::vector<std::wstring> const& input)
+static std::vector<std::vector<wchar_t>> storeArgumentsCCompatible(
+    std::vector<std::wstring> const& input)
 {
   std::vector<std::vector<wchar_t>> output;
-  std::transform(input.begin(), input.end(), std::back_inserter(output),
-                 [](std::wstring const& i) { return std::vector<wchar_t>(i.c_str(), i.c_str() + i.length() + 1); });
+  std::transform(input.begin(), input.end(), std::back_inserter(output), [](std::wstring const& i) {
+    return std::vector<wchar_t>(i.c_str(), i.c_str() + i.length() + 1);
+  });
 
   if (output.empty())
     output.emplace_back(1u, '\0');
@@ -101,10 +106,10 @@ static std::vector<wchar_t*> getCPointersToArguments(std::vector<std::vector<wch
   return output;
 }
 
-CPythonInvoker::CPythonInvoker(ILanguageInvocationHandler *invocationHandler)
-  : ILanguageInvoker(invocationHandler),
-    m_threadState(NULL), m_stop(false)
-{ }
+CPythonInvoker::CPythonInvoker(ILanguageInvocationHandler* invocationHandler)
+  : ILanguageInvoker(invocationHandler), m_threadState(NULL), m_stop(false)
+{
+}
 
 CPythonInvoker::~CPythonInvoker()
 {
@@ -114,22 +119,25 @@ CPythonInvoker::~CPythonInvoker()
     return;
 
   if (GetState() < InvokerStateExecutionDone)
-    CLog::Log(LOGDEBUG, "CPythonInvoker(%d): waiting for python thread \"%s\" to stop",
-      GetId(), (!m_sourceFile.empty() ? m_sourceFile.c_str() : "unknown script"));
+    CLog::Log(LOGDEBUG, "CPythonInvoker(%d): waiting for python thread \"%s\" to stop", GetId(),
+              (!m_sourceFile.empty() ? m_sourceFile.c_str() : "unknown script"));
   Stop(true);
   pulseGlobalEvent();
 
   onExecutionFinalized();
 }
 
-bool CPythonInvoker::Execute(const std::string &script, const std::vector<std::string> &arguments /* = std::vector<std::string>() */)
+bool CPythonInvoker::Execute(
+    const std::string& script,
+    const std::vector<std::string>& arguments /* = std::vector<std::string>() */)
 {
   if (script.empty())
     return false;
 
   if (!CFile::Exists(script))
   {
-    CLog::Log(LOGERROR, "CPythonInvoker(%d): python script \"%s\" does not exist", GetId(), CSpecialProtocol::TranslatePath(script).c_str());
+    CLog::Log(LOGERROR, "CPythonInvoker(%d): python script \"%s\" does not exist", GetId(),
+              CSpecialProtocol::TranslatePath(script).c_str());
     return false;
   }
 
@@ -139,7 +147,7 @@ bool CPythonInvoker::Execute(const std::string &script, const std::vector<std::s
   return ILanguageInvoker::Execute(script, arguments);
 }
 
-bool CPythonInvoker::execute(const std::string &script, const std::vector<std::string> &arguments)
+bool CPythonInvoker::execute(const std::string& script, const std::vector<std::string>& arguments)
 {
   std::vector<std::wstring> w_arguments;
   for (auto argument : arguments)
@@ -284,7 +292,8 @@ bool CPythonInvoker::execute(const std::string& script, const std::vector<std::w
   // set current directory and python's path.
   PySys_SetArgv(argc, &argv[0]);
 
-  CLog::Log(LOGDEBUG, "CPythonInvoker(%d, %s): entering source directory %s", GetId(), m_sourceFile.c_str(), scriptDir.c_str());
+  CLog::Log(LOGDEBUG, "CPythonInvoker(%d, %s): entering source directory %s", GetId(),
+            m_sourceFile.c_str(), scriptDir.c_str());
   PyObject* module = PyImport_AddModule("__main__");
   PyObject* moduleDict = PyModule_GetDict(module);
 
@@ -309,7 +318,9 @@ bool CPythonInvoker::execute(const std::string& script, const std::vector<std::w
 #ifdef TARGET_WINDOWS
       if (!g_charsetConverter.utf8ToSystem(nativeFilename, true))
       {
-        CLog::Log(LOGERROR, "CPythonInvoker(%d, %s): can't convert filename \"%s\" to system encoding", GetId(), m_sourceFile.c_str(), realFilename.c_str());
+        CLog::Log(LOGERROR,
+                  "CPythonInvoker(%d, %s): can't convert filename \"%s\" to system encoding",
+                  GetId(), m_sourceFile.c_str(), realFilename.c_str());
         return false;
       }
 #endif
@@ -324,11 +335,13 @@ bool CPythonInvoker::execute(const std::string& script, const std::vector<std::w
 
         Py_DECREF(f);
         setState(InvokerStateRunning);
-        XBMCAddon::Python::PyContext pycontext; // this is a guard class that marks this callstack as being in a python context
+        XBMCAddon::Python::PyContext
+            pycontext; // this is a guard class that marks this callstack as being in a python context
         executeScript(fp, realFilename, moduleDict);
       }
       else
-        CLog::Log(LOGERROR, "CPythonInvoker(%d, %s): %s not found!", GetId(), m_sourceFile.c_str(), m_sourceFile.c_str());
+        CLog::Log(LOGERROR, "CPythonInvoker(%d, %s): %s not found!", GetId(), m_sourceFile.c_str(),
+                  m_sourceFile.c_str());
     }
     catch (const XbmcCommons::Exception& e)
     {
@@ -339,7 +352,8 @@ bool CPythonInvoker::execute(const std::string& script, const std::vector<std::w
     catch (...)
     {
       setState(InvokerStateFailed);
-      CLog::Log(LOGERROR, "CPythonInvoker(%d, %s): failure in script", GetId(), m_sourceFile.c_str());
+      CLog::Log(LOGERROR, "CPythonInvoker(%d, %s): failure in script", GetId(),
+                m_sourceFile.c_str());
       failed = true;
     }
   }
@@ -348,7 +362,8 @@ bool CPythonInvoker::execute(const std::string& script, const std::vector<std::w
   InvokerState stateToSet;
   if (!failed && !PyErr_Occurred())
   {
-    CLog::Log(LOGINFO, "CPythonInvoker(%d, %s): script successfully run", GetId(), m_sourceFile.c_str());
+    CLog::Log(LOGINFO, "CPythonInvoker(%d, %s): script successfully run", GetId(),
+              m_sourceFile.c_str());
     stateToSet = InvokerStateScriptDone;
     onSuccess();
   }
@@ -366,9 +381,11 @@ bool CPythonInvoker::execute(const std::string& script, const std::vector<std::w
     // if it failed with an exception we already logged the details
     if (!failed)
     {
-      PythonBindings::PythonToCppException *e = NULL;
-      if (PythonBindings::PythonToCppException::ParsePythonException(exceptionType, exceptionValue, exceptionTraceback))
-        e = new PythonBindings::PythonToCppException(exceptionType, exceptionValue, exceptionTraceback);
+      PythonBindings::PythonToCppException* e = NULL;
+      if (PythonBindings::PythonToCppException::ParsePythonException(exceptionType, exceptionValue,
+                                                                     exceptionTraceback))
+        e = new PythonBindings::PythonToCppException(exceptionType, exceptionValue,
+                                                     exceptionTraceback);
       else
         e = new PythonBindings::PythonToCppException();
 
@@ -491,7 +508,9 @@ bool CPythonInvoker::stop(bool abort)
     {
       if (timeout.IsTimePast())
       {
-        CLog::Log(LOGERROR, "CPythonInvoker(%d, %s): script didn't stop in %d seconds - let's kill it", GetId(), m_sourceFile.c_str(), PYTHON_SCRIPT_TIMEOUT / 1000);
+        CLog::Log(LOGERROR,
+                  "CPythonInvoker(%d, %s): script didn't stop in %d seconds - let's kill it",
+                  GetId(), m_sourceFile.c_str(), PYTHON_SCRIPT_TIMEOUT / 1000);
         break;
       }
 
@@ -510,7 +529,8 @@ bool CPythonInvoker::stop(bool abort)
 
     // Useful for add-on performance metrics
     if (!timeout.IsTimePast())
-      CLog::Log(LOGDEBUG, "CPythonInvoker(%d, %s): script termination took %dms", GetId(), m_sourceFile.c_str(), PYTHON_SCRIPT_TIMEOUT - timeout.MillisLeft());
+      CLog::Log(LOGDEBUG, "CPythonInvoker(%d, %s): script termination took %dms", GetId(),
+                m_sourceFile.c_str(), PYTHON_SCRIPT_TIMEOUT - timeout.MillisLeft());
 
     // Since we released the m_critical it's possible that the state is cleaned up
     // so we need to recheck for m_threadState == NULL
@@ -606,7 +626,8 @@ void CPythonInvoker::onExecutionFailed()
   PyEval_SaveThread();
 
   setState(InvokerStateFailed);
-  CLog::Log(LOGERROR, "CPythonInvoker(%d, %s): abnormally terminating python thread", GetId(), m_sourceFile.c_str());
+  CLog::Log(LOGERROR, "CPythonInvoker(%d, %s): abnormally terminating python thread", GetId(),
+            m_sourceFile.c_str());
 
   CSingleLock lock(m_critical);
   m_threadState = NULL;
@@ -624,11 +645,12 @@ void CPythonInvoker::onInitialization()
 
   // get a possible initialization script
   const char* runscript = getInitializationScript();
-  if (runscript!= NULL && strlen(runscript) > 0)
+  if (runscript != NULL && strlen(runscript) > 0)
   {
     // redirecting default output to debug console
     if (PyRun_SimpleString(runscript) == -1)
-      CLog::Log(LOGFATAL, "CPythonInvoker(%d, %s): initialize error", GetId(), m_sourceFile.c_str());
+      CLog::Log(LOGFATAL, "CPythonInvoker(%d, %s): initialize error", GetId(),
+                m_sourceFile.c_str());
   }
 }
 
@@ -637,7 +659,7 @@ void CPythonInvoker::onPythonModuleInitialization(void* moduleDict)
   if (m_addon.get() == NULL || moduleDict == NULL)
     return;
 
-  PyObject *moduleDictionary = (PyObject *)moduleDict;
+  PyObject* moduleDictionary = (PyObject*)moduleDict;
 
   PyObject* pyaddonid = PyUnicode_FromString(m_addon->ID().c_str());
   PyDict_SetItemString(moduleDictionary, "__xbmcaddonid__", pyaddonid);
@@ -646,10 +668,12 @@ void CPythonInvoker::onPythonModuleInitialization(void* moduleDict)
   PyObject* pyxbmcapiversion = PyUnicode_FromString(version.asString().c_str());
   PyDict_SetItemString(moduleDictionary, "__xbmcapiversion__", pyxbmcapiversion);
 
-  PyObject *pyinvokerid = PyLong_FromLong(GetId());
+  PyObject* pyinvokerid = PyLong_FromLong(GetId());
   PyDict_SetItemString(moduleDictionary, "__xbmcinvokerid__", pyinvokerid);
 
-  CLog::Log(LOGDEBUG, "CPythonInvoker(%d, %s): instantiating addon using automatically obtained id of \"%s\" dependent on version %s of the xbmc.python api",
+  CLog::Log(LOGDEBUG,
+            "CPythonInvoker(%d, %s): instantiating addon using automatically obtained id of \"%s\" "
+            "dependent on version %s of the xbmc.python api",
             GetId(), m_sourceFile.c_str(), m_addon->ID().c_str(), version.asString().c_str());
 }
 
@@ -658,12 +682,16 @@ void CPythonInvoker::onDeinitialization()
   XBMC_TRACE;
 }
 
-void CPythonInvoker::onError(const std::string &exceptionType /* = "" */, const std::string &exceptionValue /* = "" */, const std::string &exceptionTraceback /* = "" */)
+void CPythonInvoker::onError(const std::string& exceptionType /* = "" */,
+                             const std::string& exceptionValue /* = "" */,
+                             const std::string& exceptionTraceback /* = "" */)
 {
   CPyThreadState releaseGil;
   CSingleLock gc(CServiceBroker::GetWinSystem()->GetGfxContext());
 
-  CGUIDialogKaiToast *pDlgToast = CServiceBroker::GetGUI()->GetWindowManager().GetWindow<CGUIDialogKaiToast>(WINDOW_DIALOG_KAI_TOAST);
+  CGUIDialogKaiToast* pDlgToast =
+      CServiceBroker::GetGUI()->GetWindowManager().GetWindow<CGUIDialogKaiToast>(
+          WINDOW_DIALOG_KAI_TOAST);
   if (pDlgToast != NULL)
   {
     std::string message;
@@ -698,12 +698,13 @@
     if (m_addon && !m_addon->Name().empty())
       message = StringUtils::Format(g_localizeStrings.Get(2102).c_str(), m_addon->Name().c_str());
     else
-       message = g_localizeStrings.Get(2103);
+      message = g_localizeStrings.Get(2103);
     pDlgToast->QueueNotification(CGUIDialogKaiToast::Error, message, g_localizeStrings.Get(2104));
   }
 }
 
-void CPythonInvoker::initializeModules(const std::map<std::string, PythonModuleInitialization> &modules)
+void CPythonInvoker::initializeModules(
+    const std::map<std::string, PythonModuleInitialization> &modules)
 {
   for (const auto& module : modules)
   {
diff --git a/xbmc/interfaces/python/PythonInvoker.h b/xbmc/interfaces/python/PythonInvoker.h
index 0ea3bfa15433..87e987d0f75d 100644
--- a/xbmc/interfaces/python/PythonInvoker.h
+++ b/xbmc/interfaces/python/PythonInvoker.h
@@ -23,10 +23,11 @@ typedef struct _object PyObject;
 class CPythonInvoker : public ILanguageInvoker
 {
 public:
-  explicit CPythonInvoker(ILanguageInvocationHandler *invocationHandler);
+  explicit CPythonInvoker(ILanguageInvocationHandler* invocationHandler);
   ~CPythonInvoker() override;
 
-  bool Execute(const std::string &script, const std::vector<std::string> &arguments = std::vector<std::string>()) override;
+  bool Execute(const std::string& script,
+               const std::vector<std::string>& arguments = std::vector<std::string>()) override;
 
   bool IsStopping() const override { return m_stop || ILanguageInvoker::IsStopping(); }
 
@@ -34,7 +35,7 @@ class CPythonInvoker : public ILanguageInvoker
 
 protected:
   // implementation of ILanguageInvoker
-  bool execute(const std::string &script, const std::vector<std::string> &arguments) override;
+  bool execute(const std::string& script, const std::vector<std::string>& arguments) override;
   virtual void executeScript(FILE* fp, const std::string& script, PyObject* moduleDict);
   bool stop(bool abort) override;
   void onExecutionDone() override;
@@ -48,15 +49,17 @@ class CPythonInvoker : public ILanguageInvoker
   virtual void onPythonModuleInitialization(void* moduleDict);
   virtual void onDeinitialization();
 
-  virtual void onSuccess() { }
-  virtual void onAbort() { }
-  virtual void onError(const std::string &exceptionType = "", const std::string &exceptionValue = "", const std::string &exceptionTraceback = "");
+  virtual void onSuccess() {}
+  virtual void onAbort() {}
+  virtual void onError(const std::string& exceptionType = "",
+                       const std::string& exceptionValue = "",
+                       const std::string& exceptionTraceback = "");
 
   std::string m_sourceFile;
   CCriticalSection m_critical;
 
 private:
-  void initializeModules(const std::map<std::string, PythonModuleInitialization> &modules);
+  void initializeModules(const std::map<std::string, PythonModuleInitialization>& modules);
   bool initializeModule(PythonModuleInitialization module);
   void addPath(const std::string& path); // add path in UTF-8 encoding
   void getAddonModuleDeps(const ADDON::AddonPtr& addon, std::set<std::string>& paths);
